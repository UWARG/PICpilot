From e591fee56a101972633ef0a3c76fd1596f66b3c7 Mon Sep 17 00:00:00 2001
From: Ben Hudson <ben@hudsonsathome.com>
Date: Tue, 31 Mar 2015 20:41:09 -0400
Subject: [PATCH] separated gps from path following

---
 InterchipDMA.c                      |   2 +-
 InterchipDMA.h                      |   6 +-
 NMEAparser.c                        | 203 +++++++++++++
 NMEAparser.h                        |  18 ++
 PathManager.c                       | 565 ++++++++++++++++++++++++++++++++++++
 PathManger.c                        | 560 -----------------------------------
 UART2.c                             |  69 ++++-
 UART2.h                             |  24 +-
 main.h                              |   2 +-
 nbproject/Makefile-default.mk       |  58 ++--
 nbproject/Makefile-local-default.mk |  21 +-
 nbproject/configurations.xml        |   6 +-
 nbproject/project.xml               |   3 +-
 net_inbound.c                       |  82 +++---
 14 files changed, 964 insertions(+), 655 deletions(-)
 create mode 100644 NMEAparser.c
 create mode 100644 NMEAparser.h
 create mode 100644 PathManager.c
 delete mode 100644 PathManger.c

diff --git a/InterchipDMA.c b/InterchipDMA.c
index 6cd4a18..e13bc26 100644
--- a/InterchipDMA.c
+++ b/InterchipDMA.c
@@ -45,7 +45,7 @@ void __attribute__((__interrupt__, no_auto_psv)) _DMA0Interrupt(void){
         transmitInitialized = 1;
         DMA1REQbits.FORCE = 1;
     while (DMA1REQbits.FORCE == 1);
-    }   
+    }
 #endif
     newDataAvailable = 1;
     IFS0bits.DMA0IF = 0;// Clear the DMA0 Interrupt Flag
diff --git a/InterchipDMA.h b/InterchipDMA.h
index 4e0fc90..f33617f 100644
--- a/InterchipDMA.h
+++ b/InterchipDMA.h
@@ -1,4 +1,4 @@
-/* 
+/*
  * File:   InterchipDMA.h
  * Author: Chris Hajduk
  *
@@ -42,8 +42,8 @@ typedef struct _AMData {
 
 #if PATH_MANAGER
 typedef struct _GPSData {
-    long double latitude;  //8 Bytes
-    long double longitude; //8 Bytes
+    double latitude;  //8 Bytes
+    double longitude; //8 Bytes
     float time;     //4 Bytes
     float speed;
     int altitude;
diff --git a/NMEAparser.c b/NMEAparser.c
new file mode 100644
index 0000000..7e59be0
--- /dev/null
+++ b/NMEAparser.c
@@ -0,0 +1,203 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <float.h>
+#include <math.h>
+#include "UART1.h"
+#include "UART2.h"
+#include "NMEAparser.h"
+//#include "InterchipDMA.c"
+//#include <libpic30.h>
+
+
+/* This is all the information we can get.
+GGA:
+- latitude
+- longitude
+- position fix
+- satellite used 0 to 12
+GST:
+- std deviations
+THS:
+- heading in degrees
+RMC:
+- speed over ground
+VTG:
+- speed over ground in knots and kmh
+- fixed field (kmh)
+- course over ground (degrees)
+-
+*/
+extern GPSData gpsData;
+extern UART_RX_Buffer _buff;
+char nMsg[255];
+char dmsg[] = "$GPGGA,092725.00,4717.11399,N,00833.91590,W,1,8,1.01,499.6,M,48.0,M,,0*5B";
+short nPos = 0;
+
+// Convert Lat and Long to degrees for GLL
+double convertLatLong(char latOrLong[]) {
+	// converts coordinate to double, then truncates, then retrieves decimal value by /100
+        double input = atof(latOrLong)/100;
+        double minutes = ((input - (int)input)/60)*100;
+	// Return Decimal value + fractional value of coordinate.
+	return ((int)input + minutes);
+}
+
+//GLL
+//void parseGLL(char data[], GPSData *GPSData) {
+//
+//	char values[8][12] = {0}; //need to make a clear unused memory function? Or make dynamically allocated array...
+//	int i = 0; //increment in for loop (used to loop through 8 parameters sent to function)
+//	int j = 0; //increment in while loop (used to loop through each char in each element in data)
+//	int n = 0; //increment in while loop (used to assign each char in data to values)
+//
+//	// fills the values array with information from the data[] variable
+//	for (i = 0; i < 8; i++) {
+//		n = 0;
+//		while (data[j] != ',' && data[j] != '\0') {
+//			values[i][n] = data[j];
+//			j++;
+//			n++;
+//		}
+//		j++;
+//	}
+//
+//	// print all values to check
+////	int k = 0;
+////	for (k = 0; k < 8; k++) {
+////		printf("%s : %s\n", names[k], values[k]);
+////	}
+//
+////	printf("\n");
+//
+//	// fill the GPSData struct with info from values[]
+//
+//	GPSData->latitude = convertLatLong(values[1]);
+//        if(values[2][1] == 'S') GPSData->latitude *= -1;
+//	GPSData->longitude = convertLatLong(values[3]);
+//        if(values[4][1] == 'W') GPSData->longitude *= -1;
+//	sscanf(values[5], "%f", &GPSData->time);
+//
+//        UART1_SendString(data);
+//        UART1_SendString("\n\n");
+//        UART1_SendString(values[4]);
+//        UART1_SendString("\n\n");
+//        char buffer[100];
+//	sprintf(buffer,"Latitude in GPS object: %f\n", GPSData->latitude);
+//        UART1_SendString(buffer);
+//        sprintf(buffer,"Longitude in GPS object: %f\n", GPSData->longitude);
+//        UART1_SendString(buffer);
+//	printf("Time in GPS Object: %f\n", GPSData->time);
+//
+//}
+
+// GGA (this only gives altitude)
+void parseGGA(char data[], GPSData *GData) {
+	char values[15][12] = {0}; //need to make a clear unused memory function? Or make dynamically allocated array...
+	int i = 0; //increment in for loop (used to loop through 8 parameters sent to function)
+	int j = 0; //increment in while loop (used to loop through each char in each element in data)
+	int n = 0; //increment in while loop (used to assign each char in data to values)
+
+	// fills the values array with information from the data[] variable
+	for (i = 0; i < 15; i++) {
+		n = 0;
+		while (data[j] != ',' && data[j] != '\0') {
+			values[i][n] = data[j];
+			j++;
+			n++;
+		}
+		j++;
+	}
+	// fill the GPSData struct with info from values[]
+
+        // fill the GPSData struct with info from values[]
+	GData->latitude = convertLatLong(values[2]);
+        if(values[3][0] == 'S') GData->latitude *= -1;
+	GData->longitude = convertLatLong(values[4]);
+        if(values[5][0] == 'W') GData->longitude *= -1;
+        sscanf(values[1], "%f", &GData->time);
+
+	sscanf(values[9], "%d", &GData->altitude);
+        sscanf(values[6], "%c", &GData->positionFix); //0 is no fix, 1 or 2 is valid fix, 6 is dead reckoning
+        sscanf(values[8], "%c", &GData->satellites); //Space Vehicles used, value between 0 and 12
+
+//        char buffer[100];
+//	sprintf(buffer,"Latitude: %f\n", GData->latitude);
+//        UART1_SendString(buffer);
+//        sprintf(buffer,"Longitude: %f\n", GData->longitude);
+//        UART1_SendString(buffer);
+//	sprintf(buffer, "Time: %f\n", GData->time);
+//        UART1_SendString(buffer);
+//	sprintf(buffer, "Altitude: %d\n", GData->altitude);
+//        UART1_SendString(buffer);
+//        sprintf(buffer, "Pos Fix: %c\n", GData->positionFix);
+//        UART1_SendString(buffer);
+//        sprintf(buffer, "Satellites: %c\n", GData->satellites);
+//        UART1_SendString(buffer);
+
+//        char buffer[100];
+//	sprintf(buffer,"altitude in GPS object: %d\n", GData->altitude);
+//        UART1_SendString(buffer);
+}
+
+//VTG
+void parseVTG(char data[], GPSData *GData) {
+
+	char values[10][7] = {0}; //need to make a clear unused memory function? Or make dynamically allocated array...
+	int i = 0; //increment in for loop (used to loop through 8 parameters sent to function)
+	int j = 0; //increment in while loop (used to loop through each char in each element in data)
+	int n = 0; //increment in while loop (used to assign each char in data to values)
+
+	// fills the values array with information from the data[] variable
+	for (i = 0; i < 10; i++) {
+		n = 0;
+		while (data[j] != ',' && data[j] != '\0') {
+			values[i][n] = data[j];
+			j++;
+			n++;
+		}
+		j++;
+	}
+
+	// fill the GPSData struct with info from values[]
+	sscanf(values[7], "%f", &GData->speed);
+        if(values[1] != 0) sscanf(values[1], "%d", &GData->heading);
+
+	GData->speed = GData->speed / 3.6;
+
+        char buffer[100];
+//	sprintf(buffer,"Speed: %f\n", GData->speed);
+//        UART1_SendString(buffer);
+        sprintf(buffer,"Course: %d\n", GData->heading);
+        UART1_SendString(buffer);
+}
+
+void assembleNEMAMessage()
+{
+    char c;
+    do
+    {
+       c = read_rx_buffer(&_buff);
+       if(c == '$')
+           nPos = 0;
+       else if (c == 0)
+           return;
+
+       nMsg[nPos] = c;
+       nPos++;
+
+       if(c == 10)
+       {
+           if(nMsg[0] == '$')
+           {
+               nMsg[nPos] = 0;
+               //if (nMsg[5] == 'L') parseGLL(nMsg,&gpsData);
+               if (nMsg[5] == 'A') parseGGA(nMsg,&gpsData);
+               if (nMsg[5] == 'G') parseVTG(nMsg,&gpsData);
+               //if (nMsg[5] == 'S') parseTHS(nMsg,&gpsData);
+               //newGPSData= true;
+           }
+           nPos = 0;
+       }
+    }  while(1);
+}
diff --git a/NMEAparser.h b/NMEAparser.h
new file mode 100644
index 0000000..2aa8f25
--- /dev/null
+++ b/NMEAparser.h
@@ -0,0 +1,18 @@
+#ifndef NMEAPARSER_H
+#define	NMEAPARSER_H
+
+#include "InterchipDMA.h"
+
+double convertLatLong(char latOrLong[]);
+//void parseGLL(char data[], GPSData *GPSData);
+void parseGGA(char data[], GPSData *GData);
+//void parseTHS(char data[], GPSData *GData);
+void parseVTG(char data[], GPSData *GData);
+
+void assembleNEMAMessage();
+
+
+
+
+#endif	/* NMEAPARSER_H */
+
diff --git a/PathManager.c b/PathManager.c
new file mode 100644
index 0000000..9f74d4c
--- /dev/null
+++ b/PathManager.c
@@ -0,0 +1,565 @@
+/*
+ * File:   PathManager.c
+ * Author: Chris Hajduk
+ *
+ * Created on February 4, 2014, 9:13 PM
+ */
+
+#include "main.h"
+#include "PathManager.h"
+#include "MPL3115A2.h"
+#include "voltageSensor.h"
+#include "NMEAparser.h"
+#include "UART2.h"
+
+#if !(PATH_MANAGER && ATTITUDE_MANAGER && COMMUNICATION_MANAGER)
+#include "InterchipDMA.h"
+#endif
+
+#if DEBUG
+#include <stdio.h>
+#include <stdlib.h>
+#include "UART1.h"
+#endif
+
+#if PATH_MANAGER
+extern GPSData gpsData;
+extern PMData pmData;
+#if !ATTITUDE_MANAGER
+extern AMData amData;
+#endif
+
+extern char newGPSDataAvailable;
+
+PathData home;
+
+float k_gain[2] = {0.01, 1};
+
+unsigned int currentBufferIndex = 0; //Last index that was filled
+unsigned int currentNodeID = 0; //Last ID that was used
+unsigned int currentIndex = 0; //Current Index that is being followed
+
+char orbitPathStatus = PATH;
+
+char lastAMDataChecksum = 0;
+
+PathData* path[PATH_BUFFER_SIZE];
+char pathStatus[PATH_BUFFER_SIZE];
+char pathCount = 0;
+
+int lastKnownHeadingHome = 10;
+char returnHome = 0;
+
+void pathManagerInit(void) {
+#if DEBUG
+    InitUART1();
+#endif
+
+    //Communication with GPS
+    InitUART2();
+    init_SPI2();
+    init_DMA2();
+    initBatterySensor();
+
+    //Interchip Communication
+#if !ATTITUDE_MANAGER
+    init_SPI1();
+    init_DMA0();
+    init_DMA1();
+    DMA1REQbits.FORCE = 1;
+    while (DMA1REQbits.FORCE == 1);
+
+    //Communication with Altimeter
+    if (initAltimeter()){
+        float initialValue = 0;
+        while (initialValue == 0) initialValue = getAltitude();
+        calibrateAltimeter(initialValue);
+    }
+#endif
+
+    //Initialize Home Location
+    home.altitude = 400;
+    home.latitude = RELATIVE_LATITUDE;
+    home.longitude = RELATIVE_LONGITUDE;
+    home.radius = 1;
+    home.id = -1;
+
+    //Initialize first path nodes
+//    PathData* node = initializePathNode();
+//    node->altitude = 10;
+//    node->latitude = 43.4731655738112;
+//    node->longitude = -80.5374240875244;
+//    node->radius = 10;
+//    appendPathNode(node);
+//    node = initializePathNode();
+//    node->altitude = 10;
+//    node->latitude = 43.4718886758826;
+//    node->longitude = -80.5391192436218;
+//    node->radius = 10;
+//    appendPathNode(node);
+}
+
+void pathManagerRuntime(void) {
+
+#if DEBUG
+//        char str[16];
+//        sprintf(&str,"%f",pmData.time);
+//        UART1_SendString(&str);
+#endif
+    //Get GPS data
+    assembleNEMAMessage();
+    copyGPSData();
+    
+    if (returnHome){
+        pmData.targetWaypoint = -1;
+    }
+    else if (path[currentIndex]->next)
+        pmData.targetWaypoint = path[currentIndex]->next->id;
+    else
+        pmData.targetWaypoint = 0;
+#if !ATTITUDE_MANAGER
+    //Check for new uplink command data
+    checkAMData();
+#endif
+    float position[3];
+    float heading;
+    //Get the position of the plane (in meters)
+    getCoordinates(gpsData.longitude,gpsData.latitude,(float*)&position);
+    position[2] = gpsData.altitude;
+    heading = (float)gpsData.heading;
+
+    if (returnHome || (pathCount - currentIndex < 1 && pathCount >= 0)){
+        pmData.sp_Heading = lastKnownHeadingHome;
+    }else if (pathCount - currentIndex >= 1){
+        if (pathCount - currentIndex >= 2){
+            currentIndex = followWaypoints(path[currentIndex], (float*)&position, heading, (int*)&pmData.sp_Heading);
+        }
+        else if (pathCount - currentIndex >= 1){
+            pmData.sp_Heading = followLastLineSegment(path[currentIndex], (float*)&position, heading);
+        }
+    }
+    if (pmData.positionFix >= 1){
+        lastKnownHeadingHome = calculateHeadingHome(home, (float*)&position, heading);
+    }
+
+
+
+}
+char followWaypoints(PathData* currentWaypoint, float* position, float heading, int* sp_Heading){
+        float waypointPosition[3];
+        getCoordinates(currentWaypoint->longitude, currentWaypoint->latitude, (float*)&waypointPosition);
+        waypointPosition[2] = currentWaypoint->altitude;
+
+
+
+        PathData* targetWaypoint = currentWaypoint->next;
+        float targetCoordinates[3];
+        getCoordinates(targetWaypoint->longitude, targetWaypoint->latitude, (float*)&targetCoordinates);
+        targetCoordinates[2] = targetWaypoint->altitude;
+                
+        PathData* nextWaypoint = targetWaypoint->next;
+        float nextCoordinates[3];
+        getCoordinates(nextWaypoint->longitude, nextWaypoint->latitude, (float*)&nextCoordinates);
+        nextCoordinates[2] = nextWaypoint->altitude;
+
+        float waypointDirection[3];
+        float norm = sqrt(pow(targetCoordinates[0] - waypointPosition[0],2) + pow(targetCoordinates[1] - waypointPosition[1],2) + pow(targetCoordinates[2] - waypointPosition[2],2));
+        waypointDirection[0] = (targetCoordinates[0] - waypointPosition[0])/norm;
+        waypointDirection[1] = (targetCoordinates[1] - waypointPosition[1])/norm;
+        waypointDirection[2] = (targetCoordinates[2] - waypointPosition[2])/norm;
+
+        float nextWaypointDirection[3];
+        float norm2 = sqrt(pow(nextCoordinates[0] - targetCoordinates[0],2) + pow(nextCoordinates[1] - targetCoordinates[1],2) + pow(nextCoordinates[2] - targetCoordinates[2],2));
+        nextWaypointDirection[0] = (nextCoordinates[0] - targetCoordinates[0])/norm2;
+        nextWaypointDirection[1] = (nextCoordinates[1] - targetCoordinates[1])/norm2;
+        nextWaypointDirection[2] = (nextCoordinates[2] - targetCoordinates[2])/norm2;
+
+        float turningAngle = acos(-deg2rad(waypointDirection[0] * nextWaypointDirection[0] + waypointDirection[1] * nextWaypointDirection[1] + waypointDirection[2] * nextWaypointDirection[2]));
+
+        if (orbitPathStatus == PATH){
+
+            float halfPlane[3];
+            halfPlane[0] = targetCoordinates[0] - (targetWaypoint->radius/tan(turningAngle/2)) * waypointDirection[0];
+            halfPlane[1] = targetCoordinates[1] - (targetWaypoint->radius/tan(turningAngle/2)) * waypointDirection[1];
+            halfPlane[2] = targetCoordinates[2] - (targetWaypoint->radius/tan(turningAngle/2)) * waypointDirection[2];
+            
+            float dotProduct = waypointDirection[0] * (position[0] - halfPlane[0]) + waypointDirection[1] * (position[1] - halfPlane[1]) + waypointDirection[2] * (position[2] - halfPlane[2]);
+            if (dotProduct > 0){
+                orbitPathStatus = ORBIT;
+            }
+
+            *sp_Heading = (int)followStraightPath((float*)&waypointDirection, (float*)targetCoordinates, (float*)position, heading);
+        }
+        else{
+            float halfPlane[3];
+            halfPlane[0] = targetCoordinates[0] + (targetWaypoint->radius/tan(turningAngle/2)) * nextWaypointDirection[0];
+            halfPlane[1] = targetCoordinates[1] + (targetWaypoint->radius/tan(turningAngle/2)) * nextWaypointDirection[1];
+            halfPlane[2] = targetCoordinates[2] + (targetWaypoint->radius/tan(turningAngle/2)) * nextWaypointDirection[2];
+
+            float dotProduct = nextWaypointDirection[0] * (position[0] - halfPlane[0]) + nextWaypointDirection[1] * (position[1] - halfPlane[1]) + nextWaypointDirection[2] * (position[2] - halfPlane[2]);
+            if (dotProduct > 0){
+                orbitPathStatus = PATH;
+                return targetWaypoint->index;
+            }
+
+            char turnDirection = waypointDirection[0] * nextWaypointDirection[1] - waypointDirection[1] * nextWaypointDirection[0]>0?1:-1;
+            float euclideanWaypointDirection = sqrt(pow(nextWaypointDirection[0] - waypointDirection[0],2) + pow(nextWaypointDirection[1] - waypointDirection[1],2) + pow(nextWaypointDirection[2] - waypointDirection[2],2)) * ((nextWaypointDirection[0] - waypointDirection[0]) < 0?-1:1) * ((nextWaypointDirection[1] - waypointDirection[1]) < 0?-1:1) * ((nextWaypointDirection[2] - waypointDirection[2]) < 0?-1:1);
+            
+            //If two waypoints are parallel to each other (no turns)
+            if (euclideanWaypointDirection == 0){
+                orbitPathStatus = PATH;
+                return targetWaypoint->index;
+            }
+
+            float turnCenter[3];
+            turnCenter[0] = targetCoordinates[0] + (targetWaypoint->radius/tan(turningAngle/2) * (nextWaypointDirection[0] - waypointDirection[0])/euclideanWaypointDirection);
+            turnCenter[1] = targetCoordinates[1] + (targetWaypoint->radius/tan(turningAngle/2) * (nextWaypointDirection[1] - waypointDirection[1])/euclideanWaypointDirection);
+            turnCenter[2] = targetCoordinates[2] + (targetWaypoint->radius/tan(turningAngle/2) * (nextWaypointDirection[2] - waypointDirection[2])/euclideanWaypointDirection);
+
+            *sp_Heading = (int)followOrbit((float*) &turnCenter,targetWaypoint->radius, turnDirection, (float*)position, heading);
+        }
+
+        return currentWaypoint->index;
+
+}
+int followLineSegment(PathData* currentWaypoint, float* position, float heading){
+        float waypointPosition[3];
+        getCoordinates(currentWaypoint->longitude, currentWaypoint->latitude, (float*)&waypointPosition);
+        waypointPosition[2] = currentWaypoint->altitude;
+
+        PathData* targetWaypoint = currentWaypoint->next;
+        float targetCoordinates[3];
+        getCoordinates(targetWaypoint->longitude, targetWaypoint->latitude, (float*)&targetCoordinates);
+        targetCoordinates[2] = targetWaypoint->altitude;
+
+
+        float waypointDirection[3];
+        float norm = sqrt(pow(targetCoordinates[0] - waypointPosition[0],2) + pow(targetCoordinates[1] - waypointPosition[1],2) + pow(targetCoordinates[2] - waypointPosition[2],2));
+        waypointDirection[0] = (targetCoordinates[0] - waypointPosition[0])/norm;
+        waypointDirection[1] = (targetCoordinates[1] - waypointPosition[1])/norm;
+        waypointDirection[2] = (targetCoordinates[2] - waypointPosition[2])/norm;
+
+        return (int)followStraightPath((float*)&waypointDirection, (float*)targetCoordinates, (float*)position, heading);
+}
+
+int followLastLineSegment(PathData* currentWaypoint, float* position, float heading){
+            float waypointPosition[3];
+        getCoordinates(currentWaypoint->longitude, currentWaypoint->latitude, (float*)&waypointPosition);
+        waypointPosition[2] = currentWaypoint->altitude;
+
+        PathData* targetWaypoint = currentWaypoint->next;
+        float targetCoordinates[3];
+        getCoordinates(targetWaypoint->longitude, targetWaypoint->latitude, (float*)&targetCoordinates);
+        targetCoordinates[2] = targetWaypoint->altitude;
+
+
+        float waypointDirection[3];
+        float norm = sqrt(pow(targetCoordinates[0] - waypointPosition[0],2) + pow(targetCoordinates[1] - waypointPosition[1],2) + pow(targetCoordinates[2] - waypointPosition[2],2));
+        waypointDirection[0] = (targetCoordinates[0] - waypointPosition[0])/norm;
+        waypointDirection[1] = (targetCoordinates[1] - waypointPosition[1])/norm;
+        waypointDirection[2] = (targetCoordinates[2] - waypointPosition[2])/norm;
+
+        float dotProduct = waypointDirection[0] * (position[0] - targetCoordinates[0]) + waypointDirection[1] * (position[1] - targetCoordinates[1]) + waypointDirection[2] * (position[2] - targetCoordinates[2]);
+        if (dotProduct > 0){
+            returnHome = 1;
+        }
+
+        return (int)followStraightPath((float*)&waypointDirection, (float*)targetCoordinates, (float*)position, heading);
+}
+
+float followOrbit(float* center, float radius, char direction, float* position, float heading){//Heading in degrees (magnetic)
+    heading = deg2rad(90 - heading);
+
+
+    float orbitDistance = sqrt(pow(position[0] - center[0],2) + pow(position[1] - center[1],2));
+    float courseAngle = atan2(position[1] - center[1], position[0] - center[0]); // (y,x) format
+ 
+    while (courseAngle - heading < -PI){
+        courseAngle += 2 * PI;
+    }
+    while (courseAngle - heading > PI){
+        courseAngle -= 2 * PI;
+    }
+
+    return 90 - rad2deg(courseAngle + direction * (PI/2 + atan(k_gain[ORBIT] * (orbitDistance - radius)/radius))); //Heading in degrees (magnetic)
+}
+float followStraightPath(float* waypointDirection, float* targetWaypoint, float* position, float heading){ //Heading in degrees (magnetic)
+    heading = deg2rad(90 - heading);//90 - heading = magnetic heading to cartesian heading
+    float courseAngle = atan2(waypointDirection[1], waypointDirection[0]); // (y,x) format
+    while (courseAngle - heading < -PI){ 
+        courseAngle += 2 * PI;
+    }
+    while (courseAngle - heading > PI){
+        courseAngle -= 2 * PI;
+    }
+
+    float pathError = -sin(courseAngle) * (position[0] - targetWaypoint[0]) + cos(courseAngle) * (position[1] - targetWaypoint[1]);
+
+    return 90 - rad2deg(courseAngle - MAX_PATH_APPROACH_ANGLE * 2/PI * atan(k_gain[PATH] * pathError)); //Heading in degrees (magnetic)
+
+}
+
+float maintainAltitude(PathData* cPath){
+    float dAltitude = cPath->next->altitude - cPath->altitude;
+    float dDistance = getDistance(cPath->longitude, cPath->latitude, cPath->next->longitude, cPath->next->latitude);
+    return getDistance(cPath->next->longitude, cPath->next->latitude, gpsData.longitude, gpsData.latitude)/dDistance * dAltitude + cPath->altitude;
+}
+
+void getCoordinates(long double longitude, long double latitude, float* xyCoordinates){
+    xyCoordinates[0] = getDistance(RELATIVE_LATITUDE, RELATIVE_LONGITUDE, RELATIVE_LATITUDE, longitude);//Longitude relative to (0,0)
+    xyCoordinates[1] = getDistance(RELATIVE_LATITUDE, RELATIVE_LONGITUDE, latitude, RELATIVE_LONGITUDE);
+}
+
+int calculateHeadingHome(PathData home, float* position, float heading){
+        float waypointPosition[3];
+        getCoordinates(position[0], position[1], (float*)&waypointPosition);
+        waypointPosition[2] = position[2];
+
+        float targetCoordinates[3];
+        getCoordinates(home.longitude, home.latitude, (float*)&targetCoordinates);
+        targetCoordinates[2] = home.altitude;
+
+
+        float waypointDirection[3];
+        float norm = sqrt(pow(targetCoordinates[0] - waypointPosition[0],2) + pow(targetCoordinates[1] - waypointPosition[1],2) + pow(targetCoordinates[2] - waypointPosition[2],2));
+        waypointDirection[0] = (targetCoordinates[0] - waypointPosition[0])/norm;
+        waypointDirection[1] = (targetCoordinates[1] - waypointPosition[1])/norm;
+        waypointDirection[2] = (targetCoordinates[2] - waypointPosition[2])/norm;
+
+        heading = deg2rad(90 - heading);//90 - heading = magnetic heading to cartesian heading
+        float courseAngle = atan2(waypointDirection[1], waypointDirection[0]);
+
+        //Don't use follow straight path in emergency situations (the gains will give you a heading that will converge over time, but not instantaneously)
+        return (int)(90 - rad2deg(courseAngle));
+}
+
+unsigned int getIndexFromID(unsigned int id) {
+    int i = 0;
+    for (i = currentBufferIndex; i >= 0; i--){
+        if (path[i]->id == id){
+            return i;
+        }
+    }
+    //If it isn't found, return -1
+    return -1;
+}
+
+PathData* initializePathNode(void) {
+//    if (nodeIndex >= PATH_BUFFER_SIZE){
+//        nodeIndex = 0;
+//    }
+    PathData* node = (PathData *) malloc(sizeof (PathData));
+    node->id = currentNodeID++;
+    node->next = 0;
+    node->previous = 0;
+    return node;
+}
+
+unsigned int destroyPathNode(PathData* node){
+    unsigned int ID = node->id;
+    free(node);
+    return ID;
+}
+
+PathData* initializePathNodeAndNext(void) {
+    PathData* temp = initializePathNode();
+    temp->next = initializePathNode();
+    temp->next->previous = temp;
+    return temp;
+}
+
+unsigned int appendPathNode(PathData* node){
+    int previousIndex = currentBufferIndex - 1;
+    if (previousIndex == -1){
+        path[currentBufferIndex] = node;
+        node->index = currentBufferIndex++;
+        pathCount++;
+        return -1;
+    }
+    PathData* previousNode = path[previousIndex];
+    node->previous = previousNode;
+    if (node->index){
+        path[currentBufferIndex] = node;
+        node->index = currentBufferIndex++;
+    }
+    
+    pathCount++;
+    //Update previous node
+    previousNode->next = node;
+
+    return node->id;
+}
+unsigned int removePathNode(unsigned int ID){ //Also attempts to destroys the node.
+
+    unsigned int nodeIndex = getIndexFromID(ID);
+    if (nodeIndex == -1){
+        return -1;
+    }
+    PathData* node = path[nodeIndex];
+    PathData* previousNode = node->previous;
+    PathData* nextNode = node->next;
+    previousNode->next = nextNode;
+    nextNode->previous = previousNode;
+
+    destroyPathNode(node);
+    path[nodeIndex] = 0;
+    pathCount--;
+    return ID;
+}
+void clearPathNodes(void){
+    int i = 0;
+    for (i = 0; i < PATH_BUFFER_SIZE; i++){
+        if (path[i]){
+            destroyPathNode(path[i]);
+        }
+        path[i] = 0;
+        pathStatus[i] = PATH_FREE;
+    }
+    pathCount = 0;
+    currentBufferIndex = 0; //Last index that was filled
+    currentNodeID = 0; //Last ID that was used
+    currentIndex = 0; //Current Index that is being followed
+}
+
+unsigned int insertPathNode(PathData* node, unsigned int previousID, unsigned int nextID){
+    int nextIndex = getIndexFromID(nextID);
+    int previousIndex = getIndexFromID(previousID);
+    if (nextIndex == -1 || previousIndex == -1){
+        return -1;
+    }
+
+    PathData* nextNode = path[nextIndex];
+    PathData* previousNode = path[previousIndex];
+    //Setup the node object first if it hasn't been initialized properly
+    if (node->index == 0){
+        path[currentBufferIndex] = node;
+        node->index = currentBufferIndex++;
+    }
+    node->next = nextNode;
+    node->previous = previousNode;
+
+    //Update previous and next nodes
+    nextNode->previous = node;
+    previousNode->next = node;
+
+    pathCount++;
+    return node->id;
+}
+
+void copyGPSData(){
+    if (newGPSDataAvailable){
+        newGPSDataAvailable = 0;
+        pmData.time = gpsData.time;
+        pmData.longitude = gpsData.longitude;
+        //pmData.altitude = getAltitude(); //gpsData.altitude;
+        pmData.latitude = gpsData.latitude;
+        pmData.heading = gpsData.heading;
+        pmData.speed = gpsData.speed;
+        pmData.satellites = (char)gpsData.satellites;
+        pmData.positionFix = (char)gpsData.positionFix;
+        pmData.batteryLevel = getCurrentPercent();
+    }
+    pmData.altitude = getAltitude(); //gpsData.altitude; //want to get altitude regardless of if there is new GPS data
+}
+
+void checkAMData(){
+    int i = 0;
+    char checksum = 0;
+    for (i = 0; i < sizeof(AMData) - 1; i++){
+        checksum += ((char *)&amData)[i];
+    }
+    if (checksum != lastAMDataChecksum && amData.checksum == checksum){
+        lastAMDataChecksum = checksum;
+        // All commands/actions that need to be run go here
+       switch (amData.command){
+            case PM_DEBUG_TEST:
+                UART1_SendString("Test");
+                break;
+            case PM_NEW_WAYPOINT:;
+                PathData* node = initializePathNode();
+                node->altitude = amData.waypoint.altitude;
+                node->latitude = amData.waypoint.latitude;
+                node->longitude = amData.waypoint.longitude;
+                node->radius = amData.waypoint.radius;
+                appendPathNode(node);
+                break;
+            case PM_CLEAR_WAYPOINTS:
+                clearPathNodes();
+                break;
+            case PM_INSERT_WAYPOINT:
+                node = initializePathNode();
+                node->altitude = amData.waypoint.altitude;
+                node->latitude = amData.waypoint.latitude;
+                node->longitude = amData.waypoint.longitude;
+                node->radius = amData.waypoint.radius;
+                insertPathNode(node,amData.waypoint.previousId,amData.waypoint.nextId);
+                break;
+            case PM_REMOVE_WAYPOINT:
+                removePathNode(amData.waypoint.id);
+                break;
+            case PM_SET_TARGET_WAYPOINT:
+                node = initializePathNode();
+                node->altitude = gpsData.altitude;
+                node->latitude = gpsData.latitude;
+                node->longitude = gpsData.longitude;
+                node->radius = 1; //Arbitrary value
+                if (path[getIndexFromID(amData.waypoint.id)] && path[getIndexFromID(amData.waypoint.id)]->previous){
+                    insertPathNode(node,path[getIndexFromID(amData.waypoint.id)]->previous->id,amData.waypoint.id);
+                    currentIndex = node->index;
+                }
+                returnHome = 0;
+
+                break;
+            case PM_SET_RETURN_HOME_COORDINATES:
+                home.altitude = amData.waypoint.altitude;
+                home.latitude = amData.waypoint.latitude;
+                home.longitude = amData.waypoint.longitude;
+                home.radius = 1;
+                home.id = -1;
+                break;
+            case PM_RETURN_HOME:
+                returnHome = 1;
+                break;
+            case PM_CANCEL_RETURN_HOME:
+                returnHome = 0;
+                break;
+
+            case PM_CALIBRATE_ALTIMETER:
+                calibrateAltimeter(amData.calibrationHeight);
+                break;
+            case PM_SET_PATH_GAIN:
+                k_gain[PATH] = amData.pathGain;
+                break;
+            case PM_SET_ORBIT_GAIN:
+                k_gain[ORBIT] = amData.orbitGain;
+                break;
+            default:
+                break;
+        }
+    }
+}
+
+char getWaypointChecksum(void){
+    unsigned int i = 0;
+    char checksum = 0;
+    for (i = 0; i < pathCount; i++){
+        checksum ^= (char)(path[i]->latitude + path[i]->longitude + path[i]->altitude + path[i]->radius) & 0xFF;
+    }
+    return checksum;
+}
+#endif
+
+float getDistance(long double lat1, long double lon1, long double lat2, long double lon2){ //in meters
+    long double dLat = deg2rad(lat2 - lat1);
+    long double dLon = deg2rad(lon2 - lon1);
+
+    float a = sin(dLat / 2) * sin(dLat / 2) + cos(deg2rad(lat1)) * cos(deg2rad(lat2)) * sin(dLon / 2) * sin(dLon / 2);
+
+    if ((dLat >= 0 && dLon >=0)||(dLat < 0 && dLon < 0)){
+        return EARTH_RADIUS * (2 * atan2(sqrt(a),sqrt(1 - a))) * 1000;
+    }
+    else {
+         return EARTH_RADIUS * (2 * atan2(sqrt(a),sqrt(1 - a))) * -1000;
+    }
+}
+
diff --git a/PathManger.c b/PathManger.c
deleted file mode 100644
index d688593..0000000
--- a/PathManger.c
+++ /dev/null
@@ -1,560 +0,0 @@
-/*
- * File:   PathManager.c
- * Author: Chris Hajduk
- *
- * Created on February 4, 2014, 9:13 PM
- */
-
-#include "main.h"
-#include "PathManager.h"
-#include "MPL3115A2.h"
-#include "voltageSensor.h"
-
-#if !(PATH_MANAGER && ATTITUDE_MANAGER && COMMUNICATION_MANAGER)
-#include "InterchipDMA.h"
-#endif
-
-#if DEBUG
-#include <stdio.h>
-#include <stdlib.h>
-#include "UART1.h"
-#endif
-
-#if PATH_MANAGER
-extern GPSData gpsData;
-extern PMData pmData;
-#if !ATTITUDE_MANAGER
-extern AMData amData;
-#endif
-
-extern char newGPSDataAvailable;
-
-PathData home;
-
-float k_gain[2] = {0.01, 1};
-
-unsigned int currentBufferIndex = 0; //Last index that was filled
-unsigned int currentNodeID = 0; //Last ID that was used
-unsigned int currentIndex = 0; //Current Index that is being followed
-
-char orbitPathStatus = PATH;
-
-char lastAMDataChecksum = 0;
-
-PathData* path[PATH_BUFFER_SIZE];
-char pathStatus[PATH_BUFFER_SIZE];
-char pathCount = 0;
-
-int lastKnownHeadingHome = 10;
-char returnHome = 0;
-
-void pathManagerInit(void) {
-#if DEBUG
-    InitUART1();
-#endif
-
-    //Communication with GPS
-        init_SPI2();
-        init_DMA2();
-        initBatterySensor();
-
-    //Interchip Communication
-#if !ATTITUDE_MANAGER
-    init_SPI1();
-    init_DMA0();
-    init_DMA1();
-    DMA1REQbits.FORCE = 1;
-    while (DMA1REQbits.FORCE == 1);
-
-    //Communication with Altimeter
-    if (initAltimeter()){
-        float initialValue = 0;
-        while (initialValue == 0) initialValue = getAltitude();
-        calibrateAltimeter(initialValue);
-    }
-#endif
-
-    //Initialize Home Location
-    home.altitude = 400;
-    home.latitude = RELATIVE_LATITUDE;
-    home.longitude = RELATIVE_LONGITUDE;
-    home.radius = 1;
-    home.id = -1;
-
-    //Initialize first path nodes
-//    PathData* node = initializePathNode();
-//    node->altitude = 10;
-//    node->latitude = 43.4731655738112;
-//    node->longitude = -80.5374240875244;
-//    node->radius = 10;
-//    appendPathNode(node);
-//    node = initializePathNode();
-//    node->altitude = 10;
-//    node->latitude = 43.4718886758826;
-//    node->longitude = -80.5391192436218;
-//    node->radius = 10;
-//    appendPathNode(node);
-}
-
-void pathManagerRuntime(void) {
-
-#if DEBUG
-//        char str[16];
-//        sprintf(&str,"%f",pmData.time);
-//        UART1_SendString(&str);
-#endif
-    //Get GPS data
-    copyGPSData();
-    if (returnHome){
-        pmData.targetWaypoint = -1;
-    }
-    else if (path[currentIndex]->next)
-        pmData.targetWaypoint = path[currentIndex]->next->id;
-    else
-        pmData.targetWaypoint = 0;
-#if !ATTITUDE_MANAGER
-    //Check for new uplink command data
-    checkAMData();
-#endif
-    float position[3];
-    float heading;
-    //Get the position of the plane (in meters)
-    getCoordinates(gpsData.longitude,gpsData.latitude,(float*)&position);
-    position[2] = gpsData.altitude;
-    heading = (float)gpsData.heading;
-
-    if (returnHome || (pathCount - currentIndex < 1 && pathCount >= 0)){
-        pmData.sp_Heading = lastKnownHeadingHome;
-    }else if (pathCount - currentIndex >= 1){
-        if (pathCount - currentIndex >= 2){
-            currentIndex = followWaypoints(path[currentIndex], (float*)&position, heading, (int*)&pmData.sp_Heading);
-        }
-        else if (pathCount - currentIndex >= 1){
-            pmData.sp_Heading = followLastLineSegment(path[currentIndex], (float*)&position, heading);
-        }
-    }
-    if (pmData.positionFix >= 1){
-        lastKnownHeadingHome = calculateHeadingHome(home, (float*)&position, heading);
-    }
-
-
-
-}
-char followWaypoints(PathData* currentWaypoint, float* position, float heading, int* sp_Heading){
-        float waypointPosition[3];
-        getCoordinates(currentWaypoint->longitude, currentWaypoint->latitude, (float*)&waypointPosition);
-        waypointPosition[2] = currentWaypoint->altitude;
-
-
-
-        PathData* targetWaypoint = currentWaypoint->next;
-        float targetCoordinates[3];
-        getCoordinates(targetWaypoint->longitude, targetWaypoint->latitude, (float*)&targetCoordinates);
-        targetCoordinates[2] = targetWaypoint->altitude;
-                
-        PathData* nextWaypoint = targetWaypoint->next;
-        float nextCoordinates[3];
-        getCoordinates(nextWaypoint->longitude, nextWaypoint->latitude, (float*)&nextCoordinates);
-        nextCoordinates[2] = nextWaypoint->altitude;
-
-        float waypointDirection[3];
-        float norm = sqrt(pow(targetCoordinates[0] - waypointPosition[0],2) + pow(targetCoordinates[1] - waypointPosition[1],2) + pow(targetCoordinates[2] - waypointPosition[2],2));
-        waypointDirection[0] = (targetCoordinates[0] - waypointPosition[0])/norm;
-        waypointDirection[1] = (targetCoordinates[1] - waypointPosition[1])/norm;
-        waypointDirection[2] = (targetCoordinates[2] - waypointPosition[2])/norm;
-
-        float nextWaypointDirection[3];
-        float norm2 = sqrt(pow(nextCoordinates[0] - targetCoordinates[0],2) + pow(nextCoordinates[1] - targetCoordinates[1],2) + pow(nextCoordinates[2] - targetCoordinates[2],2));
-        nextWaypointDirection[0] = (nextCoordinates[0] - targetCoordinates[0])/norm2;
-        nextWaypointDirection[1] = (nextCoordinates[1] - targetCoordinates[1])/norm2;
-        nextWaypointDirection[2] = (nextCoordinates[2] - targetCoordinates[2])/norm2;
-
-        float turningAngle = acos(-deg2rad(waypointDirection[0] * nextWaypointDirection[0] + waypointDirection[1] * nextWaypointDirection[1] + waypointDirection[2] * nextWaypointDirection[2]));
-
-        if (orbitPathStatus == PATH){
-
-            float halfPlane[3];
-            halfPlane[0] = targetCoordinates[0] - (targetWaypoint->radius/tan(turningAngle/2)) * waypointDirection[0];
-            halfPlane[1] = targetCoordinates[1] - (targetWaypoint->radius/tan(turningAngle/2)) * waypointDirection[1];
-            halfPlane[2] = targetCoordinates[2] - (targetWaypoint->radius/tan(turningAngle/2)) * waypointDirection[2];
-            
-            float dotProduct = waypointDirection[0] * (position[0] - halfPlane[0]) + waypointDirection[1] * (position[1] - halfPlane[1]) + waypointDirection[2] * (position[2] - halfPlane[2]);
-            if (dotProduct > 0){
-                orbitPathStatus = ORBIT;
-            }
-
-            *sp_Heading = (int)followStraightPath((float*)&waypointDirection, (float*)targetCoordinates, (float*)position, heading);
-        }
-        else{
-            float halfPlane[3];
-            halfPlane[0] = targetCoordinates[0] + (targetWaypoint->radius/tan(turningAngle/2)) * nextWaypointDirection[0];
-            halfPlane[1] = targetCoordinates[1] + (targetWaypoint->radius/tan(turningAngle/2)) * nextWaypointDirection[1];
-            halfPlane[2] = targetCoordinates[2] + (targetWaypoint->radius/tan(turningAngle/2)) * nextWaypointDirection[2];
-
-            float dotProduct = nextWaypointDirection[0] * (position[0] - halfPlane[0]) + nextWaypointDirection[1] * (position[1] - halfPlane[1]) + nextWaypointDirection[2] * (position[2] - halfPlane[2]);
-            if (dotProduct > 0){
-                orbitPathStatus = PATH;
-                return targetWaypoint->index;
-            }
-
-            char turnDirection = waypointDirection[0] * nextWaypointDirection[1] - waypointDirection[1] * nextWaypointDirection[0]>0?1:-1;
-            float euclideanWaypointDirection = sqrt(pow(nextWaypointDirection[0] - waypointDirection[0],2) + pow(nextWaypointDirection[1] - waypointDirection[1],2) + pow(nextWaypointDirection[2] - waypointDirection[2],2)) * ((nextWaypointDirection[0] - waypointDirection[0]) < 0?-1:1) * ((nextWaypointDirection[1] - waypointDirection[1]) < 0?-1:1) * ((nextWaypointDirection[2] - waypointDirection[2]) < 0?-1:1);
-            
-            //If two waypoints are parallel to each other (no turns)
-            if (euclideanWaypointDirection == 0){
-                orbitPathStatus = PATH;
-                return targetWaypoint->index;
-            }
-
-            float turnCenter[3];
-            turnCenter[0] = targetCoordinates[0] + (targetWaypoint->radius/tan(turningAngle/2) * (nextWaypointDirection[0] - waypointDirection[0])/euclideanWaypointDirection);
-            turnCenter[1] = targetCoordinates[1] + (targetWaypoint->radius/tan(turningAngle/2) * (nextWaypointDirection[1] - waypointDirection[1])/euclideanWaypointDirection);
-            turnCenter[2] = targetCoordinates[2] + (targetWaypoint->radius/tan(turningAngle/2) * (nextWaypointDirection[2] - waypointDirection[2])/euclideanWaypointDirection);
-
-            *sp_Heading = (int)followOrbit((float*) &turnCenter,targetWaypoint->radius, turnDirection, (float*)position, heading);
-        }
-
-        return currentWaypoint->index;
-
-}
-int followLineSegment(PathData* currentWaypoint, float* position, float heading){
-        float waypointPosition[3];
-        getCoordinates(currentWaypoint->longitude, currentWaypoint->latitude, (float*)&waypointPosition);
-        waypointPosition[2] = currentWaypoint->altitude;
-
-        PathData* targetWaypoint = currentWaypoint->next;
-        float targetCoordinates[3];
-        getCoordinates(targetWaypoint->longitude, targetWaypoint->latitude, (float*)&targetCoordinates);
-        targetCoordinates[2] = targetWaypoint->altitude;
-
-
-        float waypointDirection[3];
-        float norm = sqrt(pow(targetCoordinates[0] - waypointPosition[0],2) + pow(targetCoordinates[1] - waypointPosition[1],2) + pow(targetCoordinates[2] - waypointPosition[2],2));
-        waypointDirection[0] = (targetCoordinates[0] - waypointPosition[0])/norm;
-        waypointDirection[1] = (targetCoordinates[1] - waypointPosition[1])/norm;
-        waypointDirection[2] = (targetCoordinates[2] - waypointPosition[2])/norm;
-
-        return (int)followStraightPath((float*)&waypointDirection, (float*)targetCoordinates, (float*)position, heading);
-}
-
-int followLastLineSegment(PathData* currentWaypoint, float* position, float heading){
-            float waypointPosition[3];
-        getCoordinates(currentWaypoint->longitude, currentWaypoint->latitude, (float*)&waypointPosition);
-        waypointPosition[2] = currentWaypoint->altitude;
-
-        PathData* targetWaypoint = currentWaypoint->next;
-        float targetCoordinates[3];
-        getCoordinates(targetWaypoint->longitude, targetWaypoint->latitude, (float*)&targetCoordinates);
-        targetCoordinates[2] = targetWaypoint->altitude;
-
-
-        float waypointDirection[3];
-        float norm = sqrt(pow(targetCoordinates[0] - waypointPosition[0],2) + pow(targetCoordinates[1] - waypointPosition[1],2) + pow(targetCoordinates[2] - waypointPosition[2],2));
-        waypointDirection[0] = (targetCoordinates[0] - waypointPosition[0])/norm;
-        waypointDirection[1] = (targetCoordinates[1] - waypointPosition[1])/norm;
-        waypointDirection[2] = (targetCoordinates[2] - waypointPosition[2])/norm;
-
-        float dotProduct = waypointDirection[0] * (position[0] - targetCoordinates[0]) + waypointDirection[1] * (position[1] - targetCoordinates[1]) + waypointDirection[2] * (position[2] - targetCoordinates[2]);
-        if (dotProduct > 0){
-            returnHome = 1;
-        }
-
-        return (int)followStraightPath((float*)&waypointDirection, (float*)targetCoordinates, (float*)position, heading);
-}
-
-float followOrbit(float* center, float radius, char direction, float* position, float heading){//Heading in degrees (magnetic)
-    heading = deg2rad(90 - heading);
-
-
-    float orbitDistance = sqrt(pow(position[0] - center[0],2) + pow(position[1] - center[1],2));
-    float courseAngle = atan2(position[1] - center[1], position[0] - center[0]); // (y,x) format
- 
-    while (courseAngle - heading < -PI){
-        courseAngle += 2 * PI;
-    }
-    while (courseAngle - heading > PI){
-        courseAngle -= 2 * PI;
-    }
-
-    return 90 - rad2deg(courseAngle + direction * (PI/2 + atan(k_gain[ORBIT] * (orbitDistance - radius)/radius))); //Heading in degrees (magnetic)
-}
-float followStraightPath(float* waypointDirection, float* targetWaypoint, float* position, float heading){ //Heading in degrees (magnetic)
-    heading = deg2rad(90 - heading);//90 - heading = magnetic heading to cartesian heading
-    float courseAngle = atan2(waypointDirection[1], waypointDirection[0]); // (y,x) format
-    while (courseAngle - heading < -PI){ 
-        courseAngle += 2 * PI;
-    }
-    while (courseAngle - heading > PI){
-        courseAngle -= 2 * PI;
-    }
-
-    float pathError = -sin(courseAngle) * (position[0] - targetWaypoint[0]) + cos(courseAngle) * (position[1] - targetWaypoint[1]);
-
-    return 90 - rad2deg(courseAngle - MAX_PATH_APPROACH_ANGLE * 2/PI * atan(k_gain[PATH] * pathError)); //Heading in degrees (magnetic)
-
-}
-
-float maintainAltitude(PathData* cPath){
-    float dAltitude = cPath->next->altitude - cPath->altitude;
-    float dDistance = getDistance(cPath->longitude, cPath->latitude, cPath->next->longitude, cPath->next->latitude);
-    return getDistance(cPath->next->longitude, cPath->next->latitude, gpsData.longitude, gpsData.latitude)/dDistance * dAltitude + cPath->altitude;
-}
-
-void getCoordinates(long double longitude, long double latitude, float* xyCoordinates){
-    xyCoordinates[0] = getDistance(RELATIVE_LATITUDE, RELATIVE_LONGITUDE, RELATIVE_LATITUDE, longitude);//Longitude relative to (0,0)
-    xyCoordinates[1] = getDistance(RELATIVE_LATITUDE, RELATIVE_LONGITUDE, latitude, RELATIVE_LONGITUDE);
-}
-
-int calculateHeadingHome(PathData home, float* position, float heading){
-        float waypointPosition[3];
-        getCoordinates(position[0], position[1], (float*)&waypointPosition);
-        waypointPosition[2] = position[2];
-
-        float targetCoordinates[3];
-        getCoordinates(home.longitude, home.latitude, (float*)&targetCoordinates);
-        targetCoordinates[2] = home.altitude;
-
-
-        float waypointDirection[3];
-        float norm = sqrt(pow(targetCoordinates[0] - waypointPosition[0],2) + pow(targetCoordinates[1] - waypointPosition[1],2) + pow(targetCoordinates[2] - waypointPosition[2],2));
-        waypointDirection[0] = (targetCoordinates[0] - waypointPosition[0])/norm;
-        waypointDirection[1] = (targetCoordinates[1] - waypointPosition[1])/norm;
-        waypointDirection[2] = (targetCoordinates[2] - waypointPosition[2])/norm;
-
-        heading = deg2rad(90 - heading);//90 - heading = magnetic heading to cartesian heading
-        float courseAngle = atan2(waypointDirection[1], waypointDirection[0]);
-
-        //Don't use follow straight path in emergency situations (the gains will give you a heading that will converge over time, but not instantaneously)
-        return (int)(90 - rad2deg(courseAngle));
-}
-
-unsigned int getIndexFromID(unsigned int id) {
-    int i = 0;
-    for (i = currentBufferIndex; i >= 0; i--){
-        if (path[i]->id == id){
-            return i;
-        }
-    }
-    //If it isn't found, return -1
-    return -1;
-}
-
-PathData* initializePathNode(void) {
-//    if (nodeIndex >= PATH_BUFFER_SIZE){
-//        nodeIndex = 0;
-//    }
-    PathData* node = (PathData *) malloc(sizeof (PathData));
-    node->id = currentNodeID++;
-    node->next = 0;
-    node->previous = 0;
-    return node;
-}
-
-unsigned int destroyPathNode(PathData* node){
-    unsigned int ID = node->id;
-    free(node);
-    return ID;
-}
-
-PathData* initializePathNodeAndNext(void) {
-    PathData* temp = initializePathNode();
-    temp->next = initializePathNode();
-    temp->next->previous = temp;
-    return temp;
-}
-
-unsigned int appendPathNode(PathData* node){
-    int previousIndex = currentBufferIndex - 1;
-    if (previousIndex == -1){
-        path[currentBufferIndex] = node;
-        node->index = currentBufferIndex++;
-        pathCount++;
-        return -1;
-    }
-    PathData* previousNode = path[previousIndex];
-    node->previous = previousNode;
-    if (node->index){
-        path[currentBufferIndex] = node;
-        node->index = currentBufferIndex++;
-    }
-    
-    pathCount++;
-    //Update previous node
-    previousNode->next = node;
-
-    return node->id;
-}
-unsigned int removePathNode(unsigned int ID){ //Also attempts to destroys the node.
-
-    unsigned int nodeIndex = getIndexFromID(ID);
-    if (nodeIndex == -1){
-        return -1;
-    }
-    PathData* node = path[nodeIndex];
-    PathData* previousNode = node->previous;
-    PathData* nextNode = node->next;
-    previousNode->next = nextNode;
-    nextNode->previous = previousNode;
-
-    destroyPathNode(node);
-    path[nodeIndex] = 0;
-    pathCount--;
-    return ID;
-}
-void clearPathNodes(void){
-    int i = 0;
-    for (i = 0; i < PATH_BUFFER_SIZE; i++){
-        if (path[i]){
-            destroyPathNode(path[i]);
-        }
-        path[i] = 0;
-        pathStatus[i] = PATH_FREE;
-    }
-    pathCount = 0;
-    currentBufferIndex = 0; //Last index that was filled
-    currentNodeID = 0; //Last ID that was used
-    currentIndex = 0; //Current Index that is being followed
-}
-
-unsigned int insertPathNode(PathData* node, unsigned int previousID, unsigned int nextID){
-    int nextIndex = getIndexFromID(nextID);
-    int previousIndex = getIndexFromID(previousID);
-    if (nextIndex == -1 || previousIndex == -1){
-        return -1;
-    }
-
-    PathData* nextNode = path[nextIndex];
-    PathData* previousNode = path[previousIndex];
-    //Setup the node object first if it hasn't been initialized properly
-    if (node->index == 0){
-        path[currentBufferIndex] = node;
-        node->index = currentBufferIndex++;
-    }
-    node->next = nextNode;
-    node->previous = previousNode;
-
-    //Update previous and next nodes
-    nextNode->previous = node;
-    previousNode->next = node;
-
-    pathCount++;
-    return node->id;
-}
-
-void copyGPSData(){
-    if (newGPSDataAvailable){
-        newGPSDataAvailable = 0;
-        pmData.time = gpsData.time;
-        pmData.longitude = gpsData.longitude;
-        //pmData.altitude = getAltitude(); //gpsData.altitude;
-        pmData.latitude = gpsData.latitude;
-        pmData.heading = gpsData.heading;
-        pmData.speed = gpsData.speed;
-        pmData.satellites = (char)gpsData.satellites;
-        pmData.positionFix = (char)gpsData.positionFix;
-        pmData.batteryLevel = getCurrentPercent();
-    }
-    pmData.altitude = getAltitude(); //gpsData.altitude; //want to get altitude regardless of if there is new GPS data
-}
-
-void checkAMData(){
-    int i = 0;
-    char checksum = 0;
-    for (i = 0; i < sizeof(AMData) - 1; i++){
-        checksum += ((char *)&amData)[i];
-    }
-    if (checksum != lastAMDataChecksum && amData.checksum == checksum){
-        lastAMDataChecksum = checksum;
-        // All commands/actions that need to be run go here
-       switch (amData.command){
-            case PM_DEBUG_TEST:
-                UART1_SendString("Test");
-                break;
-            case PM_NEW_WAYPOINT:;
-                PathData* node = initializePathNode();
-                node->altitude = amData.waypoint.altitude;
-                node->latitude = amData.waypoint.latitude;
-                node->longitude = amData.waypoint.longitude;
-                node->radius = amData.waypoint.radius;
-                appendPathNode(node);
-                break;
-            case PM_CLEAR_WAYPOINTS:
-                clearPathNodes();
-                break;
-            case PM_INSERT_WAYPOINT:
-                node = initializePathNode();
-                node->altitude = amData.waypoint.altitude;
-                node->latitude = amData.waypoint.latitude;
-                node->longitude = amData.waypoint.longitude;
-                node->radius = amData.waypoint.radius;
-                insertPathNode(node,amData.waypoint.previousId,amData.waypoint.nextId);
-                break;
-            case PM_REMOVE_WAYPOINT:
-                removePathNode(amData.waypoint.id);
-                break;
-            case PM_SET_TARGET_WAYPOINT:
-                node = initializePathNode();
-                node->altitude = gpsData.altitude;
-                node->latitude = gpsData.latitude;
-                node->longitude = gpsData.longitude;
-                node->radius = 1; //Arbitrary value
-                if (path[getIndexFromID(amData.waypoint.id)] && path[getIndexFromID(amData.waypoint.id)]->previous){
-                    insertPathNode(node,path[getIndexFromID(amData.waypoint.id)]->previous->id,amData.waypoint.id);
-                    currentIndex = node->index;
-                }
-                returnHome = 0;
-
-                break;
-            case PM_SET_RETURN_HOME_COORDINATES:
-                home.altitude = amData.waypoint.altitude;
-                home.latitude = amData.waypoint.latitude;
-                home.longitude = amData.waypoint.longitude;
-                home.radius = 1;
-                home.id = -1;
-                break;
-            case PM_RETURN_HOME:
-                returnHome = 1;
-                break;
-            case PM_CANCEL_RETURN_HOME:
-                returnHome = 0;
-                break;
-
-            case PM_CALIBRATE_ALTIMETER:
-                calibrateAltimeter(amData.calibrationHeight);
-                break;
-            case PM_SET_PATH_GAIN:
-                k_gain[PATH] = amData.pathGain;
-                break;
-            case PM_SET_ORBIT_GAIN:
-                k_gain[ORBIT] = amData.orbitGain;
-                break;
-            default:
-                break;
-        }
-    }
-}
-
-char getWaypointChecksum(void){
-    unsigned int i = 0;
-    char checksum = 0;
-    for (i = 0; i < pathCount; i++){
-        checksum ^= (char)(path[i]->latitude + path[i]->longitude + path[i]->altitude + path[i]->radius) & 0xFF;
-    }
-    return checksum;
-}
-#endif
-
-float getDistance(long double lat1, long double lon1, long double lat2, long double lon2){ //in meters
-    long double dLat = deg2rad(lat2 - lat1);
-    long double dLon = deg2rad(lon2 - lon1);
-
-    float a = sin(dLat / 2) * sin(dLat / 2) + cos(deg2rad(lat1)) * cos(deg2rad(lat2)) * sin(dLon / 2) * sin(dLon / 2);
-
-    if ((dLat >= 0 && dLon >=0)||(dLat < 0 && dLon < 0)){
-        return EARTH_RADIUS * (2 * atan2(sqrt(a),sqrt(1 - a))) * 1000;
-    }
-    else {
-         return EARTH_RADIUS * (2 * atan2(sqrt(a),sqrt(1 - a))) * -1000;
-    }
-}
-
diff --git a/UART2.c b/UART2.c
index 73cde68..e8b59e4 100644
--- a/UART2.c
+++ b/UART2.c
@@ -1,7 +1,8 @@
-
 #include <p33FJ256GP710.h>
 #include "UART2.h"
 
+UART_RX_Buffer _buff;
+
 void InitUART2()
 {
 	// This is an EXAMPLE, so brutal typing goes into explaining all bit sets
@@ -14,9 +15,9 @@ void InitUART2()
 	//U2MODEbits.notimplemented;	// Bit14
 	U2MODEbits.USIDL = 0;	// Bit13 Continue in Idle
 	U2MODEbits.IREN = 0;	// Bit12 No IR translation
-	U2MODEbits.RTSMD = 0;	// Bit11 Flow Control Mode = 0/ Simplex = 1
+	U2MODEbits.RTSMD = 0;	// Bit11 Simplex Mode
 	//U2MODEbits.notimplemented;	// Bit10
-	U2MODEbits.UEN = 0b00;		// Bits8,9 TX,RX,enabled, RTS not used CTS not used
+	U2MODEbits.UEN = 0;		// Bits8,9 TX,RX enabled, CTS,RTS not
 	U2MODEbits.WAKE = 0;	// Bit7 No Wake up (since we don't sleep here)
 	U2MODEbits.LPBACK = 0;	// Bit6 No Loop Back
 	U2MODEbits.ABAUD = 0;	// Bit5 No Autobaud (would require sending '55')
@@ -56,16 +57,23 @@ void InitUART2()
 	U2STAbits.OERR = 0;		//Bit1 *Read Only Bit*
 	U2STAbits.URXDA = 0;	//Bit0 *Read Only Bit*
 
-	IPC7 = 0x4400;	// Mid Range Interrupt Priority level, no urgent reason
+//	IPC7 = 0x4400;	// Mid Range Interrupt Priority level, no urgent reason
+
+        IPC7 = 0x4400;	// Mid Range Interrupt Priority level, no urgent reason
 
 	IFS1bits.U2TXIF = 0;	// Clear the Transmit Interrupt Flag
-	IEC1bits.U2TXIE = 0;	// Disable Transmit Interrupts
+	IEC1bits.U2TXIE = 0;	// Enable Transmit Interrupts
 	IFS1bits.U2RXIF = 0;	// Clear the Recieve Interrupt Flag
-	IEC1bits.U2RXIE = 0;	// Disable Recieve Interrupts
+	IEC1bits.U2RXIE = 1;	// Enable Recieve Interrupts
 
+	U1MODEbits.UARTEN = 1;	// And turn the peripheral on
+
+	U1STAbits.UTXEN = 1;
 	U2MODEbits.UARTEN = 1;	// And turn the peripheral on
 
 	U2STAbits.UTXEN = 1;
+
+        //PORTBbits.RB14 = 0;
 	// I think I have the thing working now.
 
 
@@ -77,11 +85,12 @@ void InitUART2()
             i++;
         }
 }
+
 void UART2_SendChar(char data)
 {
     U2TXREG = data;
     while(U2STAbits.TRMT == 0);
-    U2STAbits.TRMT = 0;
+    //U2STAbits.TRMT = 0;
 }
 
 void UART2_SendString(char *s)
@@ -94,4 +103,48 @@ void UART2_SendString(char *s)
     }while(*s != 0);
 
           UART2_SendChar('\n');
-}
\ No newline at end of file
+}
+
+void __attribute__((interrupt, no_auto_psv)) _U2RXInterrupt( void )
+{
+    write_rx_buffer(U2RXREG,&_buff);
+    IFS1bits.U2RXIF = 0;
+}
+
+void init_rx_buffer(UART_RX_Buffer *buff)
+{
+    buff->get = 0;
+    buff->put = 1;
+}
+void write_rx_buffer(char c, UART_RX_Buffer *buff)
+{
+    buff->data[buff->put] = c;
+    if(buff->put < 255)
+        buff->put++;
+    else
+        buff->put = 0;
+
+    if(buff->put == buff->get)
+    {
+        buff->get++;
+        if(buff->get > 255)
+            buff->get = 0;
+    }
+}
+char read_rx_buffer(UART_RX_Buffer *buff)
+{
+    char c = buff->data[buff->get];
+    short oldGet = buff->get;
+    if(buff->get < 255)
+        buff->get++;
+    else
+        buff->get = 0;
+
+    if(buff->get == buff->put)
+    {
+        buff->get = oldGet;
+        return 0;
+    }
+
+    return c;
+}
diff --git a/UART2.h b/UART2.h
index 6bec298..653ec08 100644
--- a/UART2.h
+++ b/UART2.h
@@ -1,14 +1,28 @@
-/* 
- * File:   UART.h
+/*
+ * File:   UART2.h
  * Author: Mitch
  *
  * Created on June 15, 2013, 2:52 PM
  */
 
-#ifndef UART_H
-#define	UART_H
-#endif	/* UART_H */
+#ifndef UART2_H
+#define	UART2_H
+
 
 void InitUART2();
 void UART2_SendString(char *s);
 void UART2_SendChar(char data);
+void __attribute__((interrupt, no_auto_psv)) _U2RXInterrupt( void );
+
+ typedef struct _UART_RX_Buffer {
+     char data[256];
+     short get;
+     short put;
+     //short size;
+} UART_RX_Buffer;
+
+void init_rx_buffer(UART_RX_Buffer *buff);
+void write_rx_buffer(char c, UART_RX_Buffer *buff);
+char read_rx_buffer(UART_RX_Buffer *buff);
+
+#endif	/* UART2_H */
diff --git a/main.h b/main.h
index e1eac2e..671ef51 100644
--- a/main.h
+++ b/main.h
@@ -26,7 +26,7 @@
 //                      the desires Pitch, Roll, Yaw on the aircraft.
 //  Communication Manager - Provides network communication (uplink/downlink) between the aircraft and
 //                          the ground station (or any other data link).
-#define PATH_MANAGER 0
+#define PATH_MANAGER 1
 #define ATTITUDE_MANAGER !PATH_MANAGER
 #define COMMUNICATION_MANAGER !PATH_MANAGER
 
diff --git a/nbproject/Makefile-default.mk b/nbproject/Makefile-default.mk
index 910f938..75d0482 100644
--- a/nbproject/Makefile-default.mk
+++ b/nbproject/Makefile-default.mk
@@ -19,7 +19,7 @@ endif
 endif
 
 # Environment
-MKDIR=gnumkdir -p
+MKDIR=mkdir -p
 RM=rm -f 
 MV=mv 
 CP=cp 
@@ -45,17 +45,17 @@ OBJECTDIR=build/${CND_CONF}/${IMAGE_TYPE}
 DISTDIR=dist/${CND_CONF}/${IMAGE_TYPE}
 
 # Source Files Quoted if spaced
-SOURCEFILES_QUOTED_IF_SPACED=MPL3115A2.c I2C.c AttitudeManager.c OrientationControl.c UART1.c StartupErrorCodes.c debug.c net_outbound.c net_inbound.c net_common.c UART2.c cameraManager.c PathManger.c InterchipDMA.c InputCapture.c OutputCompare.c PWM.c fmath.c delay.c Clock.c StringUtils.c VN100.c VN_lib.c VN_math.c VN_user.c voltageSensor.c main.c
+SOURCEFILES_QUOTED_IF_SPACED=MPL3115A2.c I2C.c AttitudeManager.c OrientationControl.c UART1.c StartupErrorCodes.c debug.c net_outbound.c net_inbound.c net_common.c UART2.c cameraManager.c InterchipDMA.c InputCapture.c OutputCompare.c PWM.c fmath.c delay.c Clock.c StringUtils.c VN100.c VN_lib.c VN_math.c VN_user.c voltageSensor.c main.c NMEAparser.c PathManager.c
 
 # Object Files Quoted if spaced
-OBJECTFILES_QUOTED_IF_SPACED=${OBJECTDIR}/MPL3115A2.o ${OBJECTDIR}/I2C.o ${OBJECTDIR}/AttitudeManager.o ${OBJECTDIR}/OrientationControl.o ${OBJECTDIR}/UART1.o ${OBJECTDIR}/StartupErrorCodes.o ${OBJECTDIR}/debug.o ${OBJECTDIR}/net_outbound.o ${OBJECTDIR}/net_inbound.o ${OBJECTDIR}/net_common.o ${OBJECTDIR}/UART2.o ${OBJECTDIR}/cameraManager.o ${OBJECTDIR}/PathManger.o ${OBJECTDIR}/InterchipDMA.o ${OBJECTDIR}/InputCapture.o ${OBJECTDIR}/OutputCompare.o ${OBJECTDIR}/PWM.o ${OBJECTDIR}/fmath.o ${OBJECTDIR}/delay.o ${OBJECTDIR}/Clock.o ${OBJECTDIR}/StringUtils.o ${OBJECTDIR}/VN100.o ${OBJECTDIR}/VN_lib.o ${OBJECTDIR}/VN_math.o ${OBJECTDIR}/VN_user.o ${OBJECTDIR}/voltageSensor.o ${OBJECTDIR}/main.o
-POSSIBLE_DEPFILES=${OBJECTDIR}/MPL3115A2.o.d ${OBJECTDIR}/I2C.o.d ${OBJECTDIR}/AttitudeManager.o.d ${OBJECTDIR}/OrientationControl.o.d ${OBJECTDIR}/UART1.o.d ${OBJECTDIR}/StartupErrorCodes.o.d ${OBJECTDIR}/debug.o.d ${OBJECTDIR}/net_outbound.o.d ${OBJECTDIR}/net_inbound.o.d ${OBJECTDIR}/net_common.o.d ${OBJECTDIR}/UART2.o.d ${OBJECTDIR}/cameraManager.o.d ${OBJECTDIR}/PathManger.o.d ${OBJECTDIR}/InterchipDMA.o.d ${OBJECTDIR}/InputCapture.o.d ${OBJECTDIR}/OutputCompare.o.d ${OBJECTDIR}/PWM.o.d ${OBJECTDIR}/fmath.o.d ${OBJECTDIR}/delay.o.d ${OBJECTDIR}/Clock.o.d ${OBJECTDIR}/StringUtils.o.d ${OBJECTDIR}/VN100.o.d ${OBJECTDIR}/VN_lib.o.d ${OBJECTDIR}/VN_math.o.d ${OBJECTDIR}/VN_user.o.d ${OBJECTDIR}/voltageSensor.o.d ${OBJECTDIR}/main.o.d
+OBJECTFILES_QUOTED_IF_SPACED=${OBJECTDIR}/MPL3115A2.o ${OBJECTDIR}/I2C.o ${OBJECTDIR}/AttitudeManager.o ${OBJECTDIR}/OrientationControl.o ${OBJECTDIR}/UART1.o ${OBJECTDIR}/StartupErrorCodes.o ${OBJECTDIR}/debug.o ${OBJECTDIR}/net_outbound.o ${OBJECTDIR}/net_inbound.o ${OBJECTDIR}/net_common.o ${OBJECTDIR}/UART2.o ${OBJECTDIR}/cameraManager.o ${OBJECTDIR}/InterchipDMA.o ${OBJECTDIR}/InputCapture.o ${OBJECTDIR}/OutputCompare.o ${OBJECTDIR}/PWM.o ${OBJECTDIR}/fmath.o ${OBJECTDIR}/delay.o ${OBJECTDIR}/Clock.o ${OBJECTDIR}/StringUtils.o ${OBJECTDIR}/VN100.o ${OBJECTDIR}/VN_lib.o ${OBJECTDIR}/VN_math.o ${OBJECTDIR}/VN_user.o ${OBJECTDIR}/voltageSensor.o ${OBJECTDIR}/main.o ${OBJECTDIR}/NMEAparser.o ${OBJECTDIR}/PathManager.o
+POSSIBLE_DEPFILES=${OBJECTDIR}/MPL3115A2.o.d ${OBJECTDIR}/I2C.o.d ${OBJECTDIR}/AttitudeManager.o.d ${OBJECTDIR}/OrientationControl.o.d ${OBJECTDIR}/UART1.o.d ${OBJECTDIR}/StartupErrorCodes.o.d ${OBJECTDIR}/debug.o.d ${OBJECTDIR}/net_outbound.o.d ${OBJECTDIR}/net_inbound.o.d ${OBJECTDIR}/net_common.o.d ${OBJECTDIR}/UART2.o.d ${OBJECTDIR}/cameraManager.o.d ${OBJECTDIR}/InterchipDMA.o.d ${OBJECTDIR}/InputCapture.o.d ${OBJECTDIR}/OutputCompare.o.d ${OBJECTDIR}/PWM.o.d ${OBJECTDIR}/fmath.o.d ${OBJECTDIR}/delay.o.d ${OBJECTDIR}/Clock.o.d ${OBJECTDIR}/StringUtils.o.d ${OBJECTDIR}/VN100.o.d ${OBJECTDIR}/VN_lib.o.d ${OBJECTDIR}/VN_math.o.d ${OBJECTDIR}/VN_user.o.d ${OBJECTDIR}/voltageSensor.o.d ${OBJECTDIR}/main.o.d ${OBJECTDIR}/NMEAparser.o.d ${OBJECTDIR}/PathManager.o.d
 
 # Object Files
-OBJECTFILES=${OBJECTDIR}/MPL3115A2.o ${OBJECTDIR}/I2C.o ${OBJECTDIR}/AttitudeManager.o ${OBJECTDIR}/OrientationControl.o ${OBJECTDIR}/UART1.o ${OBJECTDIR}/StartupErrorCodes.o ${OBJECTDIR}/debug.o ${OBJECTDIR}/net_outbound.o ${OBJECTDIR}/net_inbound.o ${OBJECTDIR}/net_common.o ${OBJECTDIR}/UART2.o ${OBJECTDIR}/cameraManager.o ${OBJECTDIR}/PathManger.o ${OBJECTDIR}/InterchipDMA.o ${OBJECTDIR}/InputCapture.o ${OBJECTDIR}/OutputCompare.o ${OBJECTDIR}/PWM.o ${OBJECTDIR}/fmath.o ${OBJECTDIR}/delay.o ${OBJECTDIR}/Clock.o ${OBJECTDIR}/StringUtils.o ${OBJECTDIR}/VN100.o ${OBJECTDIR}/VN_lib.o ${OBJECTDIR}/VN_math.o ${OBJECTDIR}/VN_user.o ${OBJECTDIR}/voltageSensor.o ${OBJECTDIR}/main.o
+OBJECTFILES=${OBJECTDIR}/MPL3115A2.o ${OBJECTDIR}/I2C.o ${OBJECTDIR}/AttitudeManager.o ${OBJECTDIR}/OrientationControl.o ${OBJECTDIR}/UART1.o ${OBJECTDIR}/StartupErrorCodes.o ${OBJECTDIR}/debug.o ${OBJECTDIR}/net_outbound.o ${OBJECTDIR}/net_inbound.o ${OBJECTDIR}/net_common.o ${OBJECTDIR}/UART2.o ${OBJECTDIR}/cameraManager.o ${OBJECTDIR}/InterchipDMA.o ${OBJECTDIR}/InputCapture.o ${OBJECTDIR}/OutputCompare.o ${OBJECTDIR}/PWM.o ${OBJECTDIR}/fmath.o ${OBJECTDIR}/delay.o ${OBJECTDIR}/Clock.o ${OBJECTDIR}/StringUtils.o ${OBJECTDIR}/VN100.o ${OBJECTDIR}/VN_lib.o ${OBJECTDIR}/VN_math.o ${OBJECTDIR}/VN_user.o ${OBJECTDIR}/voltageSensor.o ${OBJECTDIR}/main.o ${OBJECTDIR}/NMEAparser.o ${OBJECTDIR}/PathManager.o
 
 # Source Files
-SOURCEFILES=MPL3115A2.c I2C.c AttitudeManager.c OrientationControl.c UART1.c StartupErrorCodes.c debug.c net_outbound.c net_inbound.c net_common.c UART2.c cameraManager.c PathManger.c InterchipDMA.c InputCapture.c OutputCompare.c PWM.c fmath.c delay.c Clock.c StringUtils.c VN100.c VN_lib.c VN_math.c VN_user.c voltageSensor.c main.c
+SOURCEFILES=MPL3115A2.c I2C.c AttitudeManager.c OrientationControl.c UART1.c StartupErrorCodes.c debug.c net_outbound.c net_inbound.c net_common.c UART2.c cameraManager.c InterchipDMA.c InputCapture.c OutputCompare.c PWM.c fmath.c delay.c Clock.c StringUtils.c VN100.c VN_lib.c VN_math.c VN_user.c voltageSensor.c main.c NMEAparser.c PathManager.c
 
 
 CFLAGS=
@@ -166,13 +166,6 @@ ${OBJECTDIR}/cameraManager.o: cameraManager.c  nbproject/Makefile-${CND_CONF}.mk
 	${MP_CC} $(MP_EXTRA_CC_PRE)  cameraManager.c  -o ${OBJECTDIR}/cameraManager.o  -c -mcpu=$(MP_PROCESSOR_OPTION)  -MMD -MF "${OBJECTDIR}/cameraManager.o.d"      -g -D__DEBUG -D__MPLAB_DEBUGGER_ICD3=1    -omf=elf -mlarge-data -O1 -msmart-io=1 -Wall -msfr-warn=off
 	@${FIXDEPS} "${OBJECTDIR}/cameraManager.o.d" $(SILENT)  -rsi ${MP_CC_DIR}../ 
 	
-${OBJECTDIR}/PathManger.o: PathManger.c  nbproject/Makefile-${CND_CONF}.mk
-	@${MKDIR} "${OBJECTDIR}" 
-	@${RM} ${OBJECTDIR}/PathManger.o.d 
-	@${RM} ${OBJECTDIR}/PathManger.o 
-	${MP_CC} $(MP_EXTRA_CC_PRE)  PathManger.c  -o ${OBJECTDIR}/PathManger.o  -c -mcpu=$(MP_PROCESSOR_OPTION)  -MMD -MF "${OBJECTDIR}/PathManger.o.d"      -g -D__DEBUG -D__MPLAB_DEBUGGER_ICD3=1    -omf=elf -mlarge-data -O1 -msmart-io=1 -Wall -msfr-warn=off
-	@${FIXDEPS} "${OBJECTDIR}/PathManger.o.d" $(SILENT)  -rsi ${MP_CC_DIR}../ 
-	
 ${OBJECTDIR}/InterchipDMA.o: InterchipDMA.c  nbproject/Makefile-${CND_CONF}.mk
 	@${MKDIR} "${OBJECTDIR}" 
 	@${RM} ${OBJECTDIR}/InterchipDMA.o.d 
@@ -271,6 +264,20 @@ ${OBJECTDIR}/main.o: main.c  nbproject/Makefile-${CND_CONF}.mk
 	${MP_CC} $(MP_EXTRA_CC_PRE)  main.c  -o ${OBJECTDIR}/main.o  -c -mcpu=$(MP_PROCESSOR_OPTION)  -MMD -MF "${OBJECTDIR}/main.o.d"      -g -D__DEBUG -D__MPLAB_DEBUGGER_ICD3=1    -omf=elf -mlarge-data -O1 -msmart-io=1 -Wall -msfr-warn=off
 	@${FIXDEPS} "${OBJECTDIR}/main.o.d" $(SILENT)  -rsi ${MP_CC_DIR}../ 
 	
+${OBJECTDIR}/NMEAparser.o: NMEAparser.c  nbproject/Makefile-${CND_CONF}.mk
+	@${MKDIR} "${OBJECTDIR}" 
+	@${RM} ${OBJECTDIR}/NMEAparser.o.d 
+	@${RM} ${OBJECTDIR}/NMEAparser.o 
+	${MP_CC} $(MP_EXTRA_CC_PRE)  NMEAparser.c  -o ${OBJECTDIR}/NMEAparser.o  -c -mcpu=$(MP_PROCESSOR_OPTION)  -MMD -MF "${OBJECTDIR}/NMEAparser.o.d"      -g -D__DEBUG -D__MPLAB_DEBUGGER_ICD3=1    -omf=elf -mlarge-data -O1 -msmart-io=1 -Wall -msfr-warn=off
+	@${FIXDEPS} "${OBJECTDIR}/NMEAparser.o.d" $(SILENT)  -rsi ${MP_CC_DIR}../ 
+	
+${OBJECTDIR}/PathManager.o: PathManager.c  nbproject/Makefile-${CND_CONF}.mk
+	@${MKDIR} "${OBJECTDIR}" 
+	@${RM} ${OBJECTDIR}/PathManager.o.d 
+	@${RM} ${OBJECTDIR}/PathManager.o 
+	${MP_CC} $(MP_EXTRA_CC_PRE)  PathManager.c  -o ${OBJECTDIR}/PathManager.o  -c -mcpu=$(MP_PROCESSOR_OPTION)  -MMD -MF "${OBJECTDIR}/PathManager.o.d"      -g -D__DEBUG -D__MPLAB_DEBUGGER_ICD3=1    -omf=elf -mlarge-data -O1 -msmart-io=1 -Wall -msfr-warn=off
+	@${FIXDEPS} "${OBJECTDIR}/PathManager.o.d" $(SILENT)  -rsi ${MP_CC_DIR}../ 
+	
 else
 ${OBJECTDIR}/MPL3115A2.o: MPL3115A2.c  nbproject/Makefile-${CND_CONF}.mk
 	@${MKDIR} "${OBJECTDIR}" 
@@ -356,13 +363,6 @@ ${OBJECTDIR}/cameraManager.o: cameraManager.c  nbproject/Makefile-${CND_CONF}.mk
 	${MP_CC} $(MP_EXTRA_CC_PRE)  cameraManager.c  -o ${OBJECTDIR}/cameraManager.o  -c -mcpu=$(MP_PROCESSOR_OPTION)  -MMD -MF "${OBJECTDIR}/cameraManager.o.d"        -g -omf=elf -mlarge-data -O1 -msmart-io=1 -Wall -msfr-warn=off
 	@${FIXDEPS} "${OBJECTDIR}/cameraManager.o.d" $(SILENT)  -rsi ${MP_CC_DIR}../ 
 	
-${OBJECTDIR}/PathManger.o: PathManger.c  nbproject/Makefile-${CND_CONF}.mk
-	@${MKDIR} "${OBJECTDIR}" 
-	@${RM} ${OBJECTDIR}/PathManger.o.d 
-	@${RM} ${OBJECTDIR}/PathManger.o 
-	${MP_CC} $(MP_EXTRA_CC_PRE)  PathManger.c  -o ${OBJECTDIR}/PathManger.o  -c -mcpu=$(MP_PROCESSOR_OPTION)  -MMD -MF "${OBJECTDIR}/PathManger.o.d"        -g -omf=elf -mlarge-data -O1 -msmart-io=1 -Wall -msfr-warn=off
-	@${FIXDEPS} "${OBJECTDIR}/PathManger.o.d" $(SILENT)  -rsi ${MP_CC_DIR}../ 
-	
 ${OBJECTDIR}/InterchipDMA.o: InterchipDMA.c  nbproject/Makefile-${CND_CONF}.mk
 	@${MKDIR} "${OBJECTDIR}" 
 	@${RM} ${OBJECTDIR}/InterchipDMA.o.d 
@@ -461,6 +461,20 @@ ${OBJECTDIR}/main.o: main.c  nbproject/Makefile-${CND_CONF}.mk
 	${MP_CC} $(MP_EXTRA_CC_PRE)  main.c  -o ${OBJECTDIR}/main.o  -c -mcpu=$(MP_PROCESSOR_OPTION)  -MMD -MF "${OBJECTDIR}/main.o.d"        -g -omf=elf -mlarge-data -O1 -msmart-io=1 -Wall -msfr-warn=off
 	@${FIXDEPS} "${OBJECTDIR}/main.o.d" $(SILENT)  -rsi ${MP_CC_DIR}../ 
 	
+${OBJECTDIR}/NMEAparser.o: NMEAparser.c  nbproject/Makefile-${CND_CONF}.mk
+	@${MKDIR} "${OBJECTDIR}" 
+	@${RM} ${OBJECTDIR}/NMEAparser.o.d 
+	@${RM} ${OBJECTDIR}/NMEAparser.o 
+	${MP_CC} $(MP_EXTRA_CC_PRE)  NMEAparser.c  -o ${OBJECTDIR}/NMEAparser.o  -c -mcpu=$(MP_PROCESSOR_OPTION)  -MMD -MF "${OBJECTDIR}/NMEAparser.o.d"        -g -omf=elf -mlarge-data -O1 -msmart-io=1 -Wall -msfr-warn=off
+	@${FIXDEPS} "${OBJECTDIR}/NMEAparser.o.d" $(SILENT)  -rsi ${MP_CC_DIR}../ 
+	
+${OBJECTDIR}/PathManager.o: PathManager.c  nbproject/Makefile-${CND_CONF}.mk
+	@${MKDIR} "${OBJECTDIR}" 
+	@${RM} ${OBJECTDIR}/PathManager.o.d 
+	@${RM} ${OBJECTDIR}/PathManager.o 
+	${MP_CC} $(MP_EXTRA_CC_PRE)  PathManager.c  -o ${OBJECTDIR}/PathManager.o  -c -mcpu=$(MP_PROCESSOR_OPTION)  -MMD -MF "${OBJECTDIR}/PathManager.o.d"        -g -omf=elf -mlarge-data -O1 -msmart-io=1 -Wall -msfr-warn=off
+	@${FIXDEPS} "${OBJECTDIR}/PathManager.o.d" $(SILENT)  -rsi ${MP_CC_DIR}../ 
+	
 endif
 
 # ------------------------------------------------------------------------------------
@@ -486,7 +500,7 @@ else
 dist/${CND_CONF}/${IMAGE_TYPE}/PICpilot.${IMAGE_TYPE}.${OUTPUT_SUFFIX}: ${OBJECTFILES}  nbproject/Makefile-${CND_CONF}.mk   
 	@${MKDIR} dist/${CND_CONF}/${IMAGE_TYPE} 
 	${MP_CC} $(MP_EXTRA_LD_PRE)  -o dist/${CND_CONF}/${IMAGE_TYPE}/PICpilot.${IMAGE_TYPE}.${DEBUGGABLE_SUFFIX}  ${OBJECTFILES_QUOTED_IF_SPACED}      -mcpu=$(MP_PROCESSOR_OPTION)        -omf=elf -Wl,,--defsym=__MPLAB_BUILD=1,$(MP_LINKER_FILE_OPTION),--heap=16384,--stack=16,--check-sections,--data-init,--pack-data,--handles,--isr,--no-gc-sections,--fill-upper=0,--stackguard=16,--no-force-link,--smart-io,-Map="${DISTDIR}/${PROJECTNAME}.${IMAGE_TYPE}.map",--report-mem$(MP_EXTRA_LD_POST) 
-	${MP_CC_DIR}\\xc16-bin2hex dist/${CND_CONF}/${IMAGE_TYPE}/PICpilot.${IMAGE_TYPE}.${DEBUGGABLE_SUFFIX} -a  -omf=elf  
+	${MP_CC_DIR}/xc16-bin2hex dist/${CND_CONF}/${IMAGE_TYPE}/PICpilot.${IMAGE_TYPE}.${DEBUGGABLE_SUFFIX} -a  -omf=elf  
 	
 endif
 
@@ -506,7 +520,7 @@ endif
 # Enable dependency checking
 .dep.inc: .depcheck-impl
 
-DEPFILES=$(shell mplabwildcard ${POSSIBLE_DEPFILES})
+DEPFILES=$(shell "${PATH_TO_IDE_BIN}"mplabwildcard ${POSSIBLE_DEPFILES})
 ifneq (${DEPFILES},)
 include ${DEPFILES}
 endif
diff --git a/nbproject/Makefile-local-default.mk b/nbproject/Makefile-local-default.mk
index 68e1d20..28ecb9b 100644
--- a/nbproject/Makefile-local-default.mk
+++ b/nbproject/Makefile-local-default.mk
@@ -14,24 +14,23 @@
 # You can invoke make with the values of the macros:
 # $ makeMP_CC="/opt/microchip/mplabc30/v3.30c/bin/pic30-gcc" ...  
 #
-SHELL=cmd.exe
-PATH_TO_IDE_BIN=C:/Program Files (x86)/Microchip/MPLABX/mplab_ide/mplab_ide/modules/../../bin/
+PATH_TO_IDE_BIN=/opt/microchip/mplabx/v3.00.02-beta/mplab_ide/mplab_ide/modules/../../bin/
 # Adding MPLAB X bin directory to path.
-PATH:=C:/Program Files (x86)/Microchip/MPLABX/mplab_ide/mplab_ide/modules/../../bin/:$(PATH)
+PATH:=/opt/microchip/mplabx/v3.00.02-beta/mplab_ide/mplab_ide/modules/../../bin/:$(PATH)
 # Path to java used to run MPLAB X when this makefile was created
-MP_JAVA_PATH="C:\Program Files (x86)\Microchip\MPLABX\sys\java\jre1.7.0_67/bin/"
+MP_JAVA_PATH="/opt/microchip/mplabx/v3.00.02-beta/sys/java/jre1.7.0_67/bin/"
 OS_CURRENT="$(shell uname -s)"
-MP_CC="C:\Program Files (x86)\Microchip\xc16\v1.24\bin\xc16-gcc.exe"
+MP_CC="/opt/microchip/xc16/v1.24/bin/xc16-gcc"
 # MP_CPPC is not defined
 # MP_BC is not defined
-MP_AS="C:\Program Files (x86)\Microchip\xc16\v1.24\bin\xc16-as.exe"
+MP_AS="/opt/microchip/xc16/v1.24/bin/xc16-as"
 # MP_LD is not defined
-MP_AR="C:\Program Files (x86)\Microchip\xc16\v1.24\bin\xc16-ar.exe"
-DEP_GEN=${MP_JAVA_PATH}java -jar "C:/Program Files (x86)/Microchip/MPLABX/mplab_ide/mplab_ide/modules/../../bin/extractobjectdependencies.jar"
-MP_CC_DIR="C:\Program Files (x86)\Microchip\xc16\v1.24\bin"
+MP_AR="/opt/microchip/xc16/v1.24/bin/xc16-ar"
+DEP_GEN=${MP_JAVA_PATH}java -jar "/opt/microchip/mplabx/v3.00.02-beta/mplab_ide/mplab_ide/modules/../../bin/extractobjectdependencies.jar"
+MP_CC_DIR="/opt/microchip/xc16/v1.24/bin"
 # MP_CPPC_DIR is not defined
 # MP_BC_DIR is not defined
-MP_AS_DIR="C:\Program Files (x86)\Microchip\xc16\v1.24\bin"
+MP_AS_DIR="/opt/microchip/xc16/v1.24/bin"
 # MP_LD_DIR is not defined
-MP_AR_DIR="C:\Program Files (x86)\Microchip\xc16\v1.24\bin"
+MP_AR_DIR="/opt/microchip/xc16/v1.24/bin"
 # MP_BC_DIR is not defined
diff --git a/nbproject/configurations.xml b/nbproject/configurations.xml
index 727780d..2ec4040 100644
--- a/nbproject/configurations.xml
+++ b/nbproject/configurations.xml
@@ -30,6 +30,7 @@
                      projectFiles="true">
         <itemPath>InterchipDMA.h</itemPath>
         <itemPath>PathManager.h</itemPath>
+        <itemPath>NMEAparser.h</itemPath>
       </logicalFolder>
       <logicalFolder name="f4" displayName="PWM Management" projectFiles="true">
         <itemPath>OutputCompare.h</itemPath>
@@ -86,8 +87,9 @@
       <logicalFolder name="f2"
                      displayName="Path Management and GPS"
                      projectFiles="true">
-        <itemPath>PathManger.c</itemPath>
         <itemPath>InterchipDMA.c</itemPath>
+        <itemPath>NMEAparser.c</itemPath>
+        <itemPath>PathManager.c</itemPath>
       </logicalFolder>
       <logicalFolder name="f4" displayName="PWM Management" projectFiles="true">
         <itemPath>InputCapture.c</itemPath>
@@ -128,7 +130,7 @@
         <platformTool>ICD3PlatformTool</platformTool>
         <languageToolchain>XC16</languageToolchain>
         <languageToolchainVersion>1.24</languageToolchainVersion>
-        <platform>3</platform>
+        <platform>2</platform>
       </toolsSet>
       <compileType>
         <linkerTool>
diff --git a/nbproject/project.xml b/nbproject/project.xml
index 249e1e0..fd51fcf 100644
--- a/nbproject/project.xml
+++ b/nbproject/project.xml
@@ -1,4 +1,5 @@
-<?xml version="1.0" encoding="UTF-8"?><project xmlns="http://www.netbeans.org/ns/project/1">
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://www.netbeans.org/ns/project/1">
     <type>com.microchip.mplab.nbide.embedded.makeproject</type>
     <configuration>
         <data xmlns="http://www.netbeans.org/ns/make-project/1">
diff --git a/net_inbound.c b/net_inbound.c
index 8a033a6..2da9feb 100644
--- a/net_inbound.c
+++ b/net_inbound.c
@@ -62,7 +62,7 @@ struct command* createCommand( char* rawPacket ) {
     cmd->cmd = rawPacket[15];
     int i;
     int j = 0;
-    for ( i = 16; i < 15 + cmd->data_length - 12; i++ ) {   // Received packet payload starts at 15 and has 12 bytes before len 
+    for ( i = 16; i < 15 + cmd->data_length - 12; i++ ) {   // Received packet payload starts at 15 and has 12 bytes before len
         cmd->data[j++] = rawPacket[i];
     }
     cmd->data[j] = '\0';    // Null terminate the string so can use SendUart
@@ -111,43 +111,43 @@ void inboundBufferMaintenance(void) {
     }
 }
 
-void __attribute__((__interrupt__, no_auto_psv)) _U2RXInterrupt(void) {
-    unsigned char data = U2RXREG;
-    if ( rawPacketStatus[packetPos] != BUSY ) {    // no buffer available to write
-        packetPos = ( packetPos + 1  ) % RAW_PACKET_BUFFER_SIZE;
-        IFS1bits.U2RXIF = 0;
-        return;
-    }
-    switch ( payloadPos ) {
-        case 0:
-            if ( data != START_DELIMITER ) {
-//                if (U2STAbits.OERR == 1)
-//                    U2STAbits.OERR = 0;
-                IFS1bits.U2RXIF = 0;
-                return;
-            }
-            break;
-        case 1:
-            if ( data != 0 ) {
-                payloadPos = 0;
-                IFS1bits.U2RXIF = 0;
-                return;                 // packet length < 100 bytes, so msb == 0
-            }
-            break;
-        case 2:
-            payloadLength[packetPos] = data;
-            break;
-        default:        // Normally, don't do anything special
-            break;
-    }
-    rawPackets[packetPos][payloadPos++] = data;
-    if ( payloadPos && payloadPos == payloadLength[packetPos] + 3 + 1) {   // at end of packet
-        rawPacketStatus[packetPos] = READY;
-        payloadPos = 0;
-        packetPos = ( packetPos + 1  ) % RAW_PACKET_BUFFER_SIZE;
-        if ( rawPacketStatus[packetPos] == EMPTY ) {
-            rawPacketStatus[packetPos] = BUSY;
-        }
-    }
-    IFS1bits.U2RXIF = 0;
-}
\ No newline at end of file
+//void __attribute__((__interrupt__, no_auto_psv)) _U2RXInterrupt(void) {
+//    unsigned char data = U2RXREG;
+//    if ( rawPacketStatus[packetPos] != BUSY ) {    // no buffer available to write
+//        packetPos = ( packetPos + 1  ) % RAW_PACKET_BUFFER_SIZE;
+//        IFS1bits.U2RXIF = 0;
+//        return;
+//    }
+//    switch ( payloadPos ) {
+//        case 0:
+//            if ( data != START_DELIMITER ) {
+////                if (U2STAbits.OERR == 1)
+////                    U2STAbits.OERR = 0;
+//                IFS1bits.U2RXIF = 0;
+//                return;
+//            }
+//            break;
+//        case 1:
+//            if ( data != 0 ) {
+//                payloadPos = 0;
+//                IFS1bits.U2RXIF = 0;
+//                return;                 // packet length < 100 bytes, so msb == 0
+//            }
+//            break;
+//        case 2:
+//            payloadLength[packetPos] = data;
+//            break;
+//        default:        // Normally, don't do anything special
+//            break;
+//    }
+//    rawPackets[packetPos][payloadPos++] = data;
+//    if ( payloadPos && payloadPos == payloadLength[packetPos] + 3 + 1) {   // at end of packet
+//        rawPacketStatus[packetPos] = READY;
+//        payloadPos = 0;
+//        packetPos = ( packetPos + 1  ) % RAW_PACKET_BUFFER_SIZE;
+//        if ( rawPacketStatus[packetPos] == EMPTY ) {
+//            rawPacketStatus[packetPos] = BUSY;
+//        }
+//    }
+//    IFS1bits.U2RXIF = 0;
+//}
-- 
1.9.1

